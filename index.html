<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ICT Survivors 2D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0; background-color: #0d0d1a; color: #e0e0e0; font-family: 'Roboto', sans-serif; overflow: hidden;
            touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;
        }
        #game-container { position: relative; width: 100vw; height: 100vh; background-color: #1a1a2a; } /* Dark base color */
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        .modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(30, 30, 50, 0.9); padding: 2rem; border-radius: 15px; border: 3px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7); text-align: center; z-index: 100; width: 90%; max-width: 500px;
            font-family: 'Orbitron', sans-serif; letter-spacing: 1px;
            touch-action: auto; /* <-- ADD THIS LINE */
        }
        .modal h1, .modal h2 { color: #00ffff; text-shadow: 0 0 5px #00ffff; }
        .modal p { font-family: 'Roboto', sans-serif; letter-spacing: 0; color: #ccc;}
        .modal-button {
            background-color: #00ffff; color: #1e1e32; font-family: 'Orbitron', sans-serif; font-size: 1.5rem; letter-spacing: 2px;
            padding: 0.8rem 1.5rem; border-radius: 10px; border: 2px solid #80ffff; cursor: pointer; transition: all 0.2s ease;
            margin-top: 1rem; box-shadow: 0 4px #00cccc;
        }
        .modal-button:hover { background-color: #80ffff; box-shadow: 0 2px #00cccc; transform: translateY(2px); }
        .nickname-input {
            background-color: rgba(0,0,0,0.5); border: 2px solid #00ffff; color: #00ffff;
            border-radius: 8px; padding: 0.5rem; text-align: center; font-family: 'Roboto', sans-serif;
            touch-action: auto; /* <-- ADD THIS LINE */
            -webkit-user-select: text; /* Allow text selection */
            user-select: text; /* Allow text selection */
        }
        #xp-bar-container { width: 100%; height: 15px; background-color: #444; border: 2px solid #39ff14; border-radius: 5px; overflow: hidden; }
        #xp-bar-fill { height: 100%; background-color: #39ff14; width: 0%; transition: width 0.3s ease; }
        #touch-controls-container { position: absolute; bottom: 0; left: 0; right: 0; top: 0; z-index: 20; pointer-events: none; }
        .joystick-area { position: absolute; bottom: 20px; left: 20px; width: 150px; height: 150px; background-color: rgba(100, 100, 100, 0.2); border: 2px solid rgba(0, 255, 255, 0.5); border-radius: 50%; pointer-events: auto; }
        .joystick-nub { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(0, 255, 255, 0.5); border: 2px solid rgba(128, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); }
        #shoot-area { position: absolute; bottom: 0; right: 0; top: 0; left: 50%; pointer-events: auto;}
        
        /* --- New Dash Button Styles --- */
        .touch-dash-button {
            position: absolute;
            bottom: 140px; /* 100px (question btn) + 20px (gap) + 20px (base) */
            right: 20px;
            width: 80px; 
            height: 80px; 
            background-color: rgba(0, 200, 0, 0.5); /* Green for "go" */
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: white;
            z-index: 21;
            overflow: hidden; /* For cooldown mask */
        }
        .touch-dash-cooldown {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            transform: translateY(100%); /* Start hidden (at the bottom) */
            transition: transform 0.1s linear; /* Fast transition for updates */
        }
        /* --- End Dash Button Styles --- */

        .touch-bomb-button {
            position: absolute;
            bottom: 240px; /* Above dash button */
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 100, 0, 0.5); /* Orange for bombs */
            border: 2px solid rgba(255, 150, 0, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: white;
            z-index: 21;
        }

        .touch-question-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px; /* Larger tap target */
            height: 100px; /* Larger tap target */
            background-color: rgba(128, 0, 128, 0.5); /* Purple, like the HUD button */
            border: 2px solid rgba(255, 0, 255, 0.8);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: white;
            z-index: 21; /* Above joystick */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Canvas and UI elements will be created here by createUI() -->
    </div>

    <!-- Removed Supabase Import -->
    <script type="module">
        // --- DOM Elements ---
        const getEl = id => document.getElementById(id);
        const gameContainer = document.getElementById('game-container');
        let canvas, ctx, hud, scoreText, levelText, timeText, xp_hud, xpBarFill,
            levelUpModal, upgradeOptionsContainer,
            gameOverModal, finalScore, finalTime, restartButton,
            touchControlsContainer, joystickArea, joystickNub, shootArea,
            ammoText, bombText, biomeText, hudQuestionButton, questionModal, questionText, answerButtons,
            finalQuestionsCorrect, finalQuestionsIncorrect,
            touchQuestionButton, touchDashButton, touchDashCooldown, touchBombButton; // <-- Added bomb button

        function createUI() {
            gameContainer.innerHTML = `
                <canvas id="gameCanvas"></canvas>
                <div id="touch-controls-container" class="hidden">
                    <div id="joystick-area" class="joystick-area"><div id="joystick-nub" class="joystick-nub"></div></div>
                    <div id="shoot-area"></div>
                    <!-- Add new bomb button -->
                    <div id="touch-bomb-button" class="touch-bomb-button">ðŸ’£</div>
                    <!-- Add new dash button -->
                    <div id="touch-dash-button" class="touch-dash-button">
                        Dash
                        <div id="touch-dash-cooldown" class="touch-dash-cooldown"></div>
                    </div>
                    <!-- Add new touch question button -->
                    <div id="touch-question-button" class="touch-question-button">?</div>
                </div>
                <div id="hud" class="absolute top-0 left-0 right-0 p-3 text-sm sm:text-base flex justify-between items-center text-white bg-black/30 hidden">
                    <div>
                        <div>Ammo: <span id="ammo-text">50</span> <button id="hud-question-button" class="ml-2 px-2 py-0.5 text-xs bg-purple-700 rounded hover:bg-purple-600">?</button></div>
                        <div>Bombs: <span id="bomb-text">3</span></div>
                        <div>Score: <span id="score-text">0</span></div>
                    </div>
                    <div>
                        <div>Level: <span id="level-text">1</span></div>
                        <div>Biome: <span id="biome-text" style="font-weight: bold;">Normal World</span></div>
                    </div>
                    <div>Time: <span id="time-text">0s</span></div>
                </div>
                <div id="xp-hud" class="absolute bottom-0 left-0 right-0 p-3 bg-black/30 hidden">
                    <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
                </div>
                
                <!-- Start Modal Removed -->

                <div id="question-modal" class="modal hidden">
                    <h2 class="text-3xl sm:text-4xl mb-4">Ammo Question!</h2>
                    <p id="question-text" class="text-lg mb-6"></p>
                    <div id="answer-buttons" class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4"></div>
                </div>
                 <div id="level-up-modal" class="modal hidden">
                    <h2 class="text-3xl sm:text-4xl text-yellow-400 mb-6">Level Up!</h2>
                    <p class="mb-4">Choose an upgrade:</p>
                    <div id="upgrade-options-container" class="space-y-3 sm:space-y-4"></div>
                </div>
                <div id="game-over-modal" class="modal hidden">
                     <h2 class="text-4xl sm:text-5xl text-red-500 mb-2">Game Over!</h2>
                     <!-- Nickname Removed -->
                     <div class="text-left text-sm sm:text-base space-y-2 mb-6 bg-black/40 p-4 rounded-lg border border-cyan-500">
                         <p>Enemies Defeated: <span id="final-score" class="font-bold text-white float-right">0</span></p>
                         <p>Time Survived: <span id="final-time" class="font-bold text-white float-right">0s</span></p>
                         <hr class="border-cyan-500/50 my-2">
                         <p>Correct: <span id="final-questions-correct" class="font-bold text-green-400 float-right">0</span></p>
                         <p>Incorrect: <span id="final-questions-incorrect" class="font-bold text-red-400 float-right">0</span></p>
                     </div>
                     <button id="restart-button" class="modal-button">Play Again</button>
                </div>
            `;
        }
        createUI();

        function initUI() {
            canvas = getEl('gameCanvas');
            ctx = canvas.getContext('2d');
            hud = getEl('hud');
            ammoText = getEl('ammo-text');
            bombText = getEl('bomb-text');
            scoreText = getEl('score-text');
            levelText = getEl('level-text');
            biomeText = getEl('biome-text');
            timeText = getEl('time-text');
            xp_hud = getEl('xp-hud');
            xpBarFill = getEl('xp-bar-fill');
            // Start Modal elements removed
            questionModal = getEl('question-modal');
            questionText = getEl('question-text');
            answerButtons = getEl('answer-buttons');
            levelUpModal = getEl('level-up-modal');
            upgradeOptionsContainer = getEl('upgrade-options-container');
            gameOverModal = getEl('game-over-modal');
            // finalNickname removed
            finalScore = getEl('final-score');
            finalTime = getEl('final-time');
            finalQuestionsCorrect = getEl('final-questions-correct');
            finalQuestionsIncorrect = getEl('final-questions-incorrect');
            restartButton = getEl('restart-button');
            touchControlsContainer = getEl('touch-controls-container');
            joystickArea = getEl('joystick-area');
            joystickNub = getEl('joystick-nub');
            shootArea = getEl('shoot-area');
            hudQuestionButton = getEl('hud-question-button');
            touchQuestionButton = getEl('touch-question-button'); // <-- Get new button
            touchDashButton = getEl('touch-dash-button'); // <-- Get dash button
            touchDashCooldown = getEl('touch-dash-cooldown'); // <-- Get dash cooldown UI
            touchBombButton = getEl('touch-bomb-button'); // <-- Get bomb button
        }

        // --- Game State & Config ---
        let player, enemies = [], projectiles = [], xpOrbs = [], powerUpDrops = [];
        let particles = []; // <-- NEW: For particle effects
        let enemyProjectiles = []; // <-- NEW: For enemy projectiles
        let orbitalWeapons = []; // <-- NEW: For orbital weapons like axes
        let stunProjectiles = []; // <-- NEW: For stun projectiles
        let score = 0, gameTime = 0, spawnTimer = 0, gamePaused = false, gameOver = false, correctAnswers = 0, incorrectAnswers = 0;
        let bossSpawnedLevel3 = false, bossSpawnedLevel5 = false, bossSpawnedLevel10 = false; // Track boss spawns
        let lastShotTime = 0, gameLoopId;
        let chargeStartTime = 0, isCharging = false; // For charge shot
        let killStreak = 0; // For reinforcement system
        let playerNickname = "ICT_Survivor"; // Kept default nickname
        let isTouchDevice = false;
        let joystickTouchId = null;
        let joystickStart = { x: 0, y: 0 };
        let moveInput = { x: 0, y: 0 };
        let activeTouches = {}; // <-- Initialized this
        let world = { width: 1600, height: 1200 };
        let camera = { x: 0, y: 0 };

        // --- Biome System ---
        let currentBiome = 'normal';
        let lavaPits = []; // For heat biome
        const biomes = {
            normal: {
                name: 'Normal World',
                backgroundColor: '#1a1a2a',
                gridColor: '#333',
                groundColor: '#2a2a3a'
            },
            ice: {
                name: 'Ice World',
                backgroundColor: '#0a1a2a',
                gridColor: '#336699',
                groundColor: '#1a3a5a',
                friction: 0.92, // Slippery! (lower = more slippery)
                iceColor: '#4db8ff'
            },
            heat: {
                name: 'Heat World',
                backgroundColor: '#2a1a0a',
                gridColor: '#663333',
                groundColor: '#4a2a1a',
                lavaColor: '#ff4400',
                lavaDamage: 2, // Damage per frame in lava
                maxLavaPits: 8
            }
        };
        let biomeOrder = ['normal', 'ice', 'heat', 'normal']; // Cycle through biomes
        let biomeIndex = 0;

        const playerStats = {
            x: world.width / 2, y: world.height / 2, size: 20, speed: 250, health: 200, maxHealth: 500, ammo: 50, // <-- Faster speed
            fireRate: 600, projectileSpeed: 550, projectileSize: 8, projectileDamage: 25,
            shotCount: 1, pickupRadius: 80, level: 1, xp: 0, xpToNextLevel: 100,
            pierce: 0, spread: 0,
            weaponAngle: 0, vx: 0, vy: 0,
            // --- Dash Stats ---
            dashSpeed: 2000,
            dashDuration: 250, // in milliseconds
            dashCooldown: 5000, // in milliseconds
            lastDashTime: 0,
            isDashing: false,
            dashTimer: 0,
            // --- Bomb Stats ---
            bombs: 3,
            bombDamage: 100,
            bombRadius: 200,
            bombCooldown: 10000, // 10 seconds
            lastBombTime: -10000 // Allow immediate use
        };
        // --- NEW: Updated Enemies (Flowchart Shapes) ---
        const enemyTypes = [
            { id_key: "Drone", name: "Drone", size: 20, speed: 180, health: 40, xp: 10, shape: 'rectangle', color: '#ff4444', damage: 5, maxHealth: 40 }, // Red rectangle (process)
            { id_key: "Robot", name: "Robot", size: 50, speed: 40, health: 120, xp: 40, shape: 'rectangle', color: '#4488ff', damage: 10, maxHealth: 120 }, // Blue rectangle (process)
            { id_key: "Scout", name: "Scout", size: 15, speed: 220, health: 30, xp: 18, shape: 'diamond', color: '#ffff44', damage: 4, maxHealth: 30 }, // Yellow diamond (decision)
            { id_key: "Swarm", name: "Swarm", size: 7, speed: 250, health: 10, xp: 15, shape: 'diamond', color: '#88ff88', damage: 1, maxHealth: 10 }, // Green diamond (decision)
            { id_key: "Flyer", name: "Flyer", size: 12, speed: 280, health: 25, xp: 20, shape: 'oval', color: '#ff88ff', damage: 3, maxHealth: 25 }, // Pink oval (terminal)
            // NEW ENEMY TYPES
            { id_key: "Tank", name: "Tank", size: 70, speed: 30, health: 300, xp: 60, shape: 'rectangle', color: '#666666', damage: 20, maxHealth: 300 }, // Gray rectangle (process) - slow, heavy
            { id_key: "Assassin", name: "Assassin", size: 18, speed: 350, health: 20, xp: 35, shape: 'parallelogram', color: '#8800ff', damage: 15, maxHealth: 20 }, // Purple parallelogram (input/output) - fast, deadly
            { id_key: "Healer", name: "Healer", size: 25, speed: 100, health: 60, xp: 50, shape: 'oval', color: '#00ff88', damage: 2, maxHealth: 60, isHealer: true, healCooldown: 2000, lastHealTime: 0, healAmount: 15, healRadius: 150 }, // Green oval (terminal)
            { id_key: "Splitter", name: "Splitter", size: 30, speed: 120, health: 80, xp: 45, shape: 'trapezoid', color: '#ff8800', damage: 8, maxHealth: 80, isSplitter: true }, // Orange trapezoid (manual operation)
            { id_key: "Bomber", name: "Bomber", size: 22, speed: 200, health: 35, xp: 30, shape: 'diamond', color: '#ff0088', damage: 25, maxHealth: 35, isBomber: true, explosionRadius: 80, explosionDamage: 30 }, // Hot pink diamond (decision)
        ];
        const bossType = { id_key: "Boss", name: "Boss", size: 80, speed: 90, health: 900, xp: 2000, shape: 'hexagon', color: '#ff0000', damage: 250, maxHealth: 500, isBoss: true, shootCooldown: 200, lastShotTime: 0, isMultipart: true }; // Large red hexagon boss
        // --- NEW: Insane Powerups ---
        const powerUpTypes = {
            'HEALTH': { name: "Health Pack", description: "+50 Max HP", apply: (p) => { p.maxHealth += 50; p.health = Math.min(p.maxHealth, p.health + 50); } },
            'SPEED': { name: "Speed Boost", description: "+25% Move Speed", apply: (p) => p.speed *= 1.8 },
            'FIRE_RATE': { name: "Rapid Fire", description: "-25% Firing Delay", apply: (p) => p.fireRate *= 1.75 },
            'DAMAGE': { name: "Damage Up", description: "+15 Damage", apply: (p) => p.projectileDamage += 15 },
            'MULTISHOT': { name: "Spread Shot", description: "+2 Projectiles", apply: (p) => p.shotCount += 2 },
            'PIERCE': { name: "Piercing Shot", description: "Shots pierce +2 enemies", apply: (p) => p.pierce += 2 },
            'RANGE': { name: "Long-Range", description: "+50% Projectile Lifetime", apply: (p) => p.projectileLifetime = (p.projectileLifetime || 3) * 1.5 },
            'PICKUP': { name: "XP Magnet", description: "+75% Pickup Radius", apply: (p) => p.pickupRadius *= 1.75 },
            // NEW POWERUPS
            'BOMB_CAPACITY': { name: "Bomb Cache", description: "+2 Bombs", apply: (p) => p.bombs += 2 },
            'BOMB_DAMAGE': { name: "Explosive Power", description: "+50 Bomb Damage", apply: (p) => p.bombDamage += 50 },
            'BOMB_RADIUS': { name: "Bigger Boom", description: "+50% Bomb Radius", apply: (p) => p.bombRadius *= 1.5 },
            'SHIELD': { name: "Armor Plating", description: "+30 Max HP & Damage Reduction", apply: (p) => { p.maxHealth += 30; p.health += 30; p.damageReduction = (p.damageReduction || 0) + 0.1; } },
            'LIFESTEAL': { name: "Vampire", description: "Heal 5 HP on kill", apply: (p) => p.lifesteal = (p.lifesteal || 0) + 5 },
            'CRIT_CHANCE': { name: "Critical Strike", description: "15% chance for 2x damage", apply: (p) => p.critChance = (p.critChance || 0) + 0.15 },
            'DASH_COOLDOWN': { name: "Quick Dash", description: "-30% Dash Cooldown", apply: (p) => p.dashCooldown *= 0.7 },
            // NEWEST POWERUPS
            'ORBITAL_AXE': { name: "Spinning Axes", description: "Axes orbit around you", apply: (p) => { p.orbitalCount = (p.orbitalCount || 0) + 1; addOrbitalWeapon(); } },
            'CHARGE_SHOT': { name: "Mega Cannon", description: "Hold Space for huge shot", apply: (p) => p.hasChargeShot = true },
            'STUN_SHOT': { name: "Stunner", description: "Stun projectiles pierce infinitely", apply: (p) => p.hasStunShot = true },
            'RAGE_MODE': { name: "Berserker Rage", description: "10s mega boost at low HP", apply: (p) => p.hasRageMode = true }
        };

        // --- ICT Question Bank from XML ---
        const ictQuestions = [
            { q: "What is the collective term for all websites and web pages available online through the internet?", a: ["Uniform Resource Locator", "Domain Name Server", "World Wide Web", "Hypertext Transfer Protocol"], c: 2 },
            { q: "What is defined as a huge infrastructure used by homes, businesses, and institutions worldwide to connect to each other?", a: ["The World Wide Web", "The internet", "A Web Server", "A Local Area Network"], c: 1 },
            { q: "Which component is NOT one of the three main components of a URL?", a: ["Protocol", "Domain name", "Web page or file name", "IP Address"], c: 3 },
            { q: "What is the specialized server that stores domain names along with their equivalent IP addresses?", a: ["Web Server", "Proxy Server", "Certificate Authority", "Domain Name Server (DNS)"], c: 3 },
            { q: "What is the protocol used for the transmission of web pages and related data across the internet?", a: ["HTML", "CSS", "HTTP", "SSL"], c: 2 },
            { q: "What is HTTPS?", a: ["Hypertext Template Transmission Service", "A secure version of HTTP that encrypts data for transmission", "A scripting language for web page interaction", "A protocol for searching data"], c: 1 },
            { q: "What is the software application that allows access to information available on the World Wide Web?", a: ["Search engine", "DNS", "Web server", "Web browser"], c: 3 },
            { q: "What protocol encrypts data for transmission and is combined with HTTP to create HTTPS?", a: ["TLS", "SSL (Secure Sockets Layer)", "DNS", "TCP/IP"], c: 1 },
            { q: "What are small text files used to store data about your frequent online activities?", a: ["Data packets", "Active scripts", "Cookies", "Digital ledgers"], c: 2 },
            { q: "What type of cookie is deleted when the web browser is closed?", a: ["Persistent cookies", "Targeted cookies", "Session cookies", "Temporary cookies"], c: 2 },
            { q: "What is the decentralized system that tracks all transactions for cryptocurrency?", a: ["Digital Ledger", "Proxy Server", "Blockchain", "Domain Name Server"], c: 2 },
            { q: "What is the practice of defending computers, servers, networks, and data from malicious attacks?", a: ["Social engineering", "Hacking", "Data interception", "Cyber security"], c: 3 },
            { q: "What software is used to examine data packets as they are sent across a network or the internet for the purpose of interception?", a: ["Anti-malware", "Botnet", "Packet sniffer", "Firewall"], c: 2 },
            { q: "What does DDoS stand for?", a: ["Data Definition of Service", "Digital Distribution of Systems", "Decentralized Denial of Service", "Distributed Denial of Service"], c: 3 },
            { q: "What is the general term used to describe any malicious software designed to disrupt your computer or data?", a: ["Botnet", "Hacker", "Malware", "Digital certificate"], c: 2 },
            { q: "What malware encrypts data and stops the user from accessing it, demanding money to decrypt it?", a: ["Trojan horse", "Adware", "Worm", "Ransomware"], c: 3 },
            { q: "What is phishing?", a: ["Manipulating employees into providing key information", "Encrypting user data and demanding a ransom", "Sending a user a fake email designed to look genuine, encouraging data submission", "Redirecting website requests to a malicious site"], c: 2 },
            { q: "What is the definition of the Program Development Life Cycle (PDLC)?", a: ["The process of testing a system using abnormal data", "The writing of a program using programming languages", "A series of structured steps/activities followed to produce a system", "A diagrammatic representation of an algorithm"], c: 2 },
            { q: "What term refers to taking a system and splitting it into smaller sub-systems?", a: ["Verification", "Validation", "Decomposition", "Coding"], c: 2 },
            { q: "What is a diagrammatic representation of an algorithm?", a: ["Pseudocode", "Structure diagram", "Flowchart", "Trace table"], c: 2 },
            { q: "Which type of test data is data that a program *should not* accept?", a: ["Normal test data", "Extreme test data", "Abnormal test data", "Boundary test data"], c: 2 },
            { q: "What is a series of steps that searches for a specific value in a set of data?", a: ["Sorting algorithm", "Bubble sort", "Search algorithm", "Validation check"], c: 2 },
            { q: "What is the process of checking that data entered is reasonable and within bounds?", a: ["Verification", "Validation", "Trace table entry", "Linear search"], c: 1 },
            { q: "Which verification method requires two different people to enter the same data?", a: ["Visual check", "Range check", "Double-entry check", "Presence check"], c: 2 },
            { q: "What search algorithm visits each item of data in turn to check whether it is the data being looked for?", a: ["Bubble sort", "Binary search", "Linear search", "Minimum search"], c: 2 },
            { q: "What sorting algorithm moves through the list repeatedly swapping values in pairs?", a: ["Linear search", "Bubble sort", "Maximum sort", "Verification sort"], c: 1 },
            { q: "What type of validation assesses whether data is within one or two bounds?", a: ["Length check", "Type check", "Range check", "Presence check"], c: 2 },
            { q: "What is the smallest value within a set?", a: ["Average", "Maximum", "Minimum", "Total"], c: 2 },
            { q: "What validation check ensures that some data has been entered?", a: ["Length check", "Range check", "Presence check", "Format check"], c: 2 },
            { q: "What is calculated from a set of numbers and is input with the numbers for validation purposes?", a: ["Check sum", "Check digit", "Control total", "Digital certificate"], c: 1 }
        ];

        // --- Question Generator ---
        const questionGenerator = {
            getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; },

            generate() {
                // Return a random ICT question from the bank
                return this.getRandom(ictQuestions);
            }
        };

        // --- Game Initialization ---
        function init() {
            enemies = []; projectiles = []; xpOrbs = []; powerUpDrops = []; particles = []; enemyProjectiles = []; orbitalWeapons = []; stunProjectiles = []; lavaPits = []; // <-- Clear all arrays including lava pits
            score = 0; gameTime = 0; spawnTimer = 0; gamePaused = false, gameOver = false;
            correctAnswers = 0; incorrectAnswers = 0;
            bossSpawnedLevel3 = false; bossSpawnedLevel5 = false; bossSpawnedLevel10 = false; // Reset boss tracking
            chargeStartTime = 0; isCharging = false; killStreak = 0; // Reset new states
            currentBiome = 'normal'; biomeIndex = 0; // Reset biome to normal
            player = JSON.parse(JSON.stringify(playerStats));
            // Reset dash state
            player.isDashing = false;
            player.dashTimer = 0;
            player.lastDashTime = 0; // Allow dash immediately
            player.rageActive = false; // Reset rage mode
            player.rageEndTime = 0;

            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            updateHUD();
            updateCooldowns(); // Set cooldown UI to ready
            [questionModal, levelUpModal, gameOverModal].forEach(m => { if(m) m.classList.add('hidden'); });
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            resizeCanvas();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Nickname and start modal logic removed
            if(hud) hud.classList.remove('hidden');
            if(xp_hud) xp_hud.classList.remove('hidden');
            init();
        }

        function endGame() {
            gameOver = true;
            gamePaused = true; 
            // finalNickname removed
            if(finalScore) finalScore.textContent = score;
            if(finalTime) finalTime.textContent = Math.floor(gameTime) + 's';
            if(finalQuestionsCorrect) finalQuestionsCorrect.textContent = correctAnswers;
            if(finalQuestionsIncorrect) finalQuestionsIncorrect.textContent = incorrectAnswers;
            if(gameOverModal) gameOverModal.classList.remove('hidden');
        }

        // --- Main Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameOver || gamePaused) {
                lastTime = timestamp;
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }
            const delta = (timestamp - (lastTime || timestamp)) / 1000 || 0;
            lastTime = timestamp;
            gameTime += delta;

            handleInput(delta);
            update(delta);
            updateCamera();
            draw();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- Input Handling ---
        let keys = {};
        function handleInput(delta) {
             if (!player || player.isDashing) return; // Don't take move input while dashing

             let targetVX = 0;
             let targetVY = 0;

            if (isTouchDevice) {
                targetVX = moveInput.x * player.speed;
                targetVY = moveInput.y * player.speed;
            } else {
                if (keys['KeyW'] || keys['ArrowUp']) targetVY = -player.speed;
                if (keys['KeyS'] || keys['ArrowDown']) targetVY = player.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) targetVX = -player.speed;
                if (keys['KeyD'] || keys['ArrowRight']) targetVX = player.speed; // FIXED: was targetVY
                if (targetVX !== 0 && targetVY !== 0) {
                     const length = Math.sqrt(targetVX * targetVX + targetVY * targetVY);
                     targetVX = (targetVX / length) * player.speed;
                     targetVY = (targetVY / length) * player.speed;
                }
            }
             // Ice biome makes movement slippery
             let lerpFactor = Math.min(1, 15 * delta);
             if (currentBiome === 'ice') {
                 // Reduce lerp factor for slippery ice
                 lerpFactor = Math.min(1, 5 * delta); // Much slower response = slippery
             }
             player.vx = (player.vx ?? 0) * (1 - lerpFactor) + targetVX * lerpFactor;
             player.vy = (player.vy ?? 0) * (1 - lerpFactor) + targetVY * lerpFactor;
        }

        // --- Update Logic ---
        function update(delta) {
            if(!player || gameOver) return;
            updatePlayer(delta);
            updateEnemies(delta);
            updateProjectiles(delta);
            updateEnemyProjectiles(delta); // <-- NEW: Update enemy projectiles
            updateOrbitalWeapons(delta); // <-- NEW: Update orbital weapons
            updateStunProjectiles(delta); // <-- NEW: Update stun projectiles
            updateDrops(delta);
            updateParticles(delta); // <-- NEW: Update particles
            handleCollisions();
            spawnEnemies(delta);
            checkBossSpawns(); // <-- NEW: Check for boss spawns
            checkRageMode(); // <-- NEW: Check rage mode
            checkKillStreak(); // <-- NEW: Check kill streak
            updateLavaPits(delta); // <-- NEW: Update lava pits for heat biome
            updateHUD();
            updateCooldowns(); // Update dash cooldown UI
        }

        function updatePlayer(delta) {
            // --- Dash Logic ---
            if (player.isDashing) {
                player.dashTimer -= delta;
                player.vx = player.dashTargetVX; // Override velocity
                player.vy = player.dashTargetVY;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                    player.vx = 0; // Stop, will be recalculated by handleInput next frame
                    player.vy = 0;
                }
                // Apply dash movement
                player.x += player.vx * delta;
                player.y += player.vy * delta;
                player.x = Math.max(player.size, Math.min(world.width - player.size, player.x));
                player.y = Math.max(player.size, Math.min(world.height - player.size, player.y));
                
                // NEW: Spawn dash trail particles
                if (Math.random() > 0.3) {
                    particles.push(createParticle(player.x, player.y, 'rgba(0, 255, 255, 0.5)', 3, 0.4, 0, 0));
                }
                return; // Skip normal update logic while dashing
            }
            // --- End Dash Logic ---

            // Normal movement (now uses lerped velocity)
            player.x += player.vx * delta;
            player.y += player.vy * delta;
            player.x = Math.max(player.size, Math.min(world.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(world.height - player.size, player.y));

            // Aiming
            let closestEnemy = null;
            let minDistSq = Infinity;
            enemies.forEach(e => {
                const dx = e.x - player.x; const dy = e.y - player.y;
                const distSq = dx*dx + dy*dy;
                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestEnemy = e;
                }
            });

            if (closestEnemy) {
                player.weaponAngle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
            } else {
                player.weaponAngle = -Math.PI / 2; // Default aim up
            }

            // Shooting
             if (keys['Space'] || keys['mouseLeft'] || (isTouchDevice && keys['touchShoot'])) {
                 if (player.hasChargeShot && !isCharging) {
                     startChargingShot();
                 }
                 shoot(player.weaponAngle);
             } else if (isCharging) {
                 releaseChargeShot();
             }

             // Auto-fire stun shots
             if (player.hasStunShot && Math.random() > 0.95) {
                 shootStunProjectile(player.weaponAngle);
             }
        }

        function updateEnemies(delta) {
             enemies.forEach(e => {
                // Check if stunned
                if (e.stunned && e.stunnedUntil > Date.now()) {
                    return; // Skip movement and actions while stunned
                } else if (e.stunned) {
                    e.stunned = false; // Remove stun
                }

                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const distSq = dx*dx + dy*dy;
                if (distSq > e.size * e.size) {
                    const dist = Math.sqrt(distSq);
                    e.x += (dx / dist) * e.speed * delta;
                    e.y += (dy / dist) * e.speed * delta;
                }

                // Boss shooting logic
                if (e.isBoss) {
                    const now = Date.now();
                    if (now - e.lastShotTime >= e.shootCooldown) {
                        e.lastShotTime = now;
                        bossShoot(e);
                    }
                }

                // Healer logic - heal nearby enemies
                if (e.isHealer) {
                    const now = Date.now();
                    if (now - e.lastHealTime >= e.healCooldown) {
                        e.lastHealTime = now;
                        enemies.forEach(target => {
                            if (target.id !== e.id && target.health < target.maxHealth) {
                                const tdx = target.x - e.x;
                                const tdy = target.y - e.y;
                                const distToTarget = Math.sqrt(tdx*tdx + tdy*tdy);
                                if (distToTarget < e.healRadius) {
                                    target.health = Math.min(target.maxHealth, target.health + e.healAmount);
                                    // Spawn heal particles
                                    spawnParticleEmitter(target.x, target.y, '#00ff88', 5);
                                }
                            }
                        });
                    }
                }
            });
        }
        function updateProjectiles(delta) {
             for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.lifetime -= delta;
                if (p.lifetime <= 0 || p.x < 0 || p.x > world.width || p.y < 0 || p.y > world.height) {
                    projectiles.splice(i, 1);
                }
             }
        }
        function updateEnemyProjectiles(delta) {
             for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.lifetime -= delta;
                if (p.lifetime <= 0 || p.x < 0 || p.x > world.width || p.y < 0 || p.y > world.height) {
                    enemyProjectiles.splice(i, 1);
                }
             }
        }
        function bossShoot(boss) {
            if (!player) return;
            const dx = player.x - boss.x;
            const dy = player.y - boss.y;
            const angle = Math.atan2(dy, dx);
            const speed = 200;

            enemyProjectiles.push({
                x: boss.x,
                y: boss.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 10,
                damage: 20,
                lifetime: 5,
                color: '#ff0000' // Red ball
            });
        }
        function updateDrops(delta) {
             xpOrbs.forEach(orb => {
                 const dx = player.x - orb.x;
                 const dy = player.y - orb.y;
                 const distSq = dx*dx + dy*dy;
                 if (distSq < player.pickupRadius * player.pickupRadius) {
                     const speed = 300 * delta;
                     const dist = Math.sqrt(distSq);
                     orb.x += (dx / dist) * speed;
                     orb.y += (dy / dist) * speed;
                 }
             });
        }
        // --- NEW: Particle System ---
        function createParticle(x, y, color, size, lifetime, vx, vy) {
            const particle = {
                x, y, color, size, lifetime,
                vx: vx || (Math.random() - 0.5) * 150,
                vy: vy || (Math.random() - 0.5) * 150,
                drag: 0.95
            };
            return particle;
        }
        function spawnParticleEmitter(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(createParticle(x, y, color, Math.random() * 3 + 1, Math.random() * 0.5 + 0.3));
            }
        }
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.vx *= p.drag;
                p.vy *= p.drag;
                p.lifetime -= delta;
                p.size = Math.max(0, p.size - delta * 2); // Shrink
                if (p.lifetime <= 0 || p.size <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        // --- End Particle System ---

        function handleCollisions() {
             if (!player) return;
            // Projectile vs Enemy
            for (let pi = projectiles.length - 1; pi >= 0; pi--) {
                const p = projectiles[pi];
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const e = enemies[ei];
                    if (p.hitEnemies?.includes(e.id)) continue;

                    let hitDetected = false;

                    // Check limb hits first for multipart bosses
                    if (e.isMultipart && e.limbs) {
                        for (let li = 0; li < e.limbs.length; li++) {
                            const limb = e.limbs[li];
                            if (limb.health <= 0) continue;

                            const limbX = e.x + limb.offsetX;
                            const limbY = e.y + limb.offsetY;

                            // Rectangle collision for limbs
                            if (p.x >= limbX - limb.width / 2 && p.x <= limbX + limb.width / 2 &&
                                p.y >= limbY - limb.height / 2 && p.y <= limbY + limb.height / 2) {

                                limb.health -= p.damage;
                                spawnParticleEmitter(p.x, p.y, limb.color, 5);

                                if (limb.health <= 0) {
                                    limb.health = 0;
                                    createXpOrb(limbX, limbY, limb.xp);
                                    spawnParticleEmitter(limbX, limbY, limb.color, 15);
                                }

                                hitDetected = true;
                                if (!p.hitEnemies) p.hitEnemies = [];
                                p.hitEnemies.push(e.id + '_limb_' + li);

                                if (p.pierceCount <= 0) {
                                    projectiles.splice(pi, 1);
                                }  else {
                                    p.pierceCount--;
                                }
                                break;
                            }
                        }
                    }

                    // If no limb hit, check body hit
                    if (!hitDetected) {
                        const dx = e.x - p.x; const dy = e.y - p.y;
                        const distSq = dx*dx + dy*dy;
                        if (distSq < (e.size + p.size) * (e.size + p.size)) {
                            handleEnemyHit(e, p.damage);
                            spawnParticleEmitter(p.x, p.y, '#ffffff', 3); // <-- NEW: Hit spark
                            if (!p.hitEnemies) p.hitEnemies = [];
                            p.hitEnemies.push(e.id);
                            if (p.pierceCount <= 0) {
                                projectiles.splice(pi, 1);
                                break;
                            } else {
                                p.pierceCount--;
                            }
                        }
                    }

                    if (hitDetected) break;
                }
            }
            // Player vs Enemy
            for (let i = enemies.length - 1; i >= 0; i--) {
                 const e = enemies[i];
                 if (player.isDashing) continue; // Invincible while dashing
                 const dx = player.x - e.x; const dy = player.y - e.y;
                 if (dx*dx + dy*dy < (player.size + e.size) * (player.size + e.size)) {
                     const damageReduction = player.damageReduction || 0;
                     const actualDamage = e.damage * (1 - damageReduction);
                     player.health -= actualDamage;
                     const angle = Math.atan2(dy, dx);
                     e.x -= Math.cos(angle) * e.size * 0.5;
                     e.y -= Math.sin(angle) * e.size * 0.5;
                     if (player.health <= 0) {
                         player.health = 0;
                         endGame();
                     }
                 }
            }
            // Player vs XP Orb
             for (let i = xpOrbs.length - 1; i >= 0; i--) {
                 const orb = xpOrbs[i];
                 const dx = player.x - orb.x; const dy = player.y - orb.y;
                 if(dx*dx + dy*dy < player.size * player.size) {
                     gainXp(orb.value);
                     xpOrbs.splice(i, 1);
                 }
            }
            // Enemy Projectiles vs Player
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                if (player.isDashing) continue; // Invincible while dashing
                const dx = player.x - p.x; const dy = player.y - p.y;
                if (dx*dx + dy*dy < (player.size + p.size) * (player.size + p.size)) {
                    const damageReduction = player.damageReduction || 0;
                    const actualDamage = p.damage * (1 - damageReduction);
                    player.health -= actualDamage;
                    spawnParticleEmitter(p.x, p.y, '#ff0000', 5); // Red impact
                    enemyProjectiles.splice(i, 1);
                    if (player.health <= 0) {
                        player.health = 0;
                        endGame();
                    }
                }
            }
        }

        function handleEnemyHit(enemy, damage) {
            enemy.health -= damage;
            if (enemy.health <= 0) {
                const index = enemies.findIndex(e => e.id === enemy.id);
                if (index > -1) {
                    killEnemy(enemies[index], index);
                }
            }
        }
        function killEnemy(enemy, index) {
            score++;
            killStreak++; // Increment kill streak
            createXpOrb(enemy.x, enemy.y, enemy.xp);
            spawnParticleEmitter(enemy.x, enemy.y, enemy.color, 20); // <-- NEW: Death explosion

            // Lifesteal - heal on kill
            if (player.lifesteal && player.lifesteal > 0) {
                player.health = Math.min(player.maxHealth, player.health + player.lifesteal);
                spawnParticleEmitter(player.x, player.y, '#00ff00', 5); // Green heal particles
            }

            // Bomber explodes on death - AOE damage to player
            if (enemy.isBomber) {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distToPlayer = Math.sqrt(dx*dx + dy*dy);
                if (distToPlayer < enemy.explosionRadius) {
                    if (!player.isDashing) { // Only damage if not dashing
                        player.health -= enemy.explosionDamage;
                        if (player.health <= 0) {
                            player.health = 0;
                            endGame();
                        }
                    }
                }
                // Explosion particles
                spawnParticleEmitter(enemy.x, enemy.y, '#ffaa00', 40);
            }

            // Splitter splits into 2 smaller enemies
            if (enemy.isSplitter) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const offset = 30;
                    enemies.push({
                        id: Math.random(),
                        x: enemy.x + Math.cos(angle) * offset,
                        y: enemy.y + Math.sin(angle) * offset,
                        id_key: "Swarm",
                        name: "Swarm",
                        size: 7,
                        speed: 250,
                        health: 10,
                        xp: 8,
                        shape: 'square',
                        color: enemy.color,
                        damage: 5,
                        maxHealth: 10
                    });
                }
            }

            // Boss defeated - change biome!
            if (enemy.isBoss) {
                changeBiome();
            }

            enemies.splice(index, 1);
        }
        function spawnEnemies(delta) {
             spawnTimer -= delta;
             const spawnInterval = Math.max(0.1, 1.5 - gameTime / 120);
             const maxEnemies = 20 + player.level * 10;
             if (spawnTimer <= 0 && enemies.length < maxEnemies) {
                 spawnEnemy();
                 spawnTimer = spawnInterval * (0.8 + Math.random() * 0.4);
             }
        }
        function spawnEnemy() {
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const spawnDist = Math.max(canvas.width, canvas.height) / 2 + 100;
            const angle = Math.random() * Math.PI * 2;
            const x = player.x + Math.cos(angle) * spawnDist;
            const y = player.y + Math.sin(angle) * spawnDist;

            enemies.push({
                id: Math.random(), x: x, y: y, ...type,
                health: type.health * (1 + gameTime / 90),
                maxHealth: type.health * (1 + gameTime / 90)
            });
        }
        function checkBossSpawns() {
            if (!player) return;

            // Spawn boss at level 3
            if (player.level >= 3 && !bossSpawnedLevel3) {
                bossSpawnedLevel3 = true;
                spawnBoss();
            }

            // Spawn boss at level 5
            if (player.level >= 5 && !bossSpawnedLevel5) {
                bossSpawnedLevel5 = true;
                spawnBoss();
            }

            // Spawn boss at level 10
            if (player.level >= 10 && !bossSpawnedLevel10) {
                bossSpawnedLevel10 = true;
                spawnBoss();
            }
        }
        function spawnBoss() {
            const spawnDist = Math.max(canvas.width, canvas.height) / 2 + 150;
            const angle = Math.random() * Math.PI * 2;
            const x = player.x + Math.cos(angle) * spawnDist;
            const y = player.y + Math.sin(angle) * spawnDist;

            // Create multipart boss with limbs
            const boss = {
                id: Math.random(), x: x, y: y, ...bossType,
                health: bossType.health,
                maxHealth: bossType.health,
                lastShotTime: Date.now() // Initialize shooting timer
            };

            // Add limbs if multipart boss
            if (boss.isMultipart) {
                boss.limbs = [
                    // Left arm
                    { id: Math.random(), type: 'leftArm', offsetX: -boss.size * 0.8, offsetY: -boss.size * 0.3, width: boss.size * 0.4, height: boss.size * 0.8, health: 150, maxHealth: 150, color: '#cc0000', xp: 300 },
                    // Right arm
                    { id: Math.random(), type: 'rightArm', offsetX: boss.size * 0.8, offsetY: -boss.size * 0.3, width: boss.size * 0.4, height: boss.size * 0.8, health: 150, maxHealth: 150, color: '#cc0000', xp: 300 },
                    // Left leg
                    { id: Math.random(), type: 'leftLeg', offsetX: -boss.size * 0.3, offsetY: boss.size * 0.8, width: boss.size * 0.35, height: boss.size * 0.6, health: 120, maxHealth: 120, color: '#aa0000', xp: 250 },
                    // Right leg
                    { id: Math.random(), type: 'rightLeg', offsetX: boss.size * 0.3, offsetY: boss.size * 0.8, width: boss.size * 0.35, height: boss.size * 0.6, health: 120, maxHealth: 120, color: '#aa0000', xp: 250 }
                ];
            }

            enemies.push(boss);
        }

        // --- Biome Functions ---
        function changeBiome() {
            biomeIndex = (biomeIndex + 1) % biomeOrder.length;
            currentBiome = biomeOrder[biomeIndex];

            // Clear lava pits when changing biome
            lavaPits = [];

            // Spawn lava pits if heat biome
            if (currentBiome === 'heat') {
                spawnLavaPits();
            }

            // Visual feedback
            const biomeInfo = biomes[currentBiome];
            spawnParticleEmitter(player.x, player.y, biomeInfo.gridColor, 50);

            // Show notification (you could add a message here)
            console.log(`Biome changed to: ${biomeInfo.name}`);
        }

        function spawnLavaPits() {
            const biomeInfo = biomes.heat;
            const numPits = biomeInfo.maxLavaPits || 8;

            for (let i = 0; i < numPits; i++) {
                const x = Math.random() * world.width;
                const y = Math.random() * world.height;
                const size = 80 + Math.random() * 100; // Random size 80-180

                lavaPits.push({
                    x: x,
                    y: y,
                    size: size,
                    damage: biomeInfo.lavaDamage,
                    lastDamageTime: 0
                });
            }
        }

        function updateLavaPits(delta) {
            if (currentBiome !== 'heat' || !player) return;

            const now = Date.now();
            for (let pit of lavaPits) {
                const dx = player.x - pit.x;
                const dy = player.y - pit.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Check if player is in lava pit
                if (dist < pit.size / 2 + player.size) {
                    // Damage player every 500ms while in lava
                    if (now - pit.lastDamageTime > 500) {
                        if (!player.isDashing) { // No damage while dashing
                            player.health -= pit.damage;
                            spawnParticleEmitter(player.x, player.y, '#ff4400', 5);

                            if (player.health <= 0) {
                                player.health = 0;
                                endGame();
                            }
                        }
                        pit.lastDamageTime = now;
                    }
                }
            }
        }

        function shoot(angle) {
            if (!player) return;
            if (player.ammo <= 0) { 
                askQuestion(); 
                return; 
            }
            if (Date.now() - lastShotTime < player.fireRate) return;
            
            player.ammo--;
            lastShotTime = Date.now();
            const spreadAngle = 0.15;

            for (let i = 0; i < player.shotCount; i++) {
                let currentAngle = angle;
                if (player.shotCount > 1) {
                    const totalSpread = spreadAngle * (player.shotCount - 1);
                    currentAngle += totalSpread / 2 - spreadAngle * i;
                }
                
                // NEW: Muzzle flash
                const muzzleX = player.x + Math.cos(currentAngle) * (player.size * 1.2);
                const muzzleY = player.y + Math.sin(currentAngle) * (player.size * 1.2);
                spawnParticleEmitter(muzzleX, muzzleY, '#ffffaa', 3);

                // Calculate damage with crit chance
                let damage = player.projectileDamage;
                let isCrit = false;
                if (player.critChance && Math.random() < player.critChance) {
                    damage *= 2;
                    isCrit = true;
                }

                projectiles.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(currentAngle) * player.projectileSpeed,
                    vy: Math.sin(currentAngle) * player.projectileSpeed,
                    size: player.projectileSize,
                    damage: damage,
                    lifetime: player.projectileLifetime || 3,
                    pierceCount: player.pierce,
                    hitEnemies: [],
                    isCrit: isCrit
                });
            }
        }
        function createXpOrb(x, y, value) {
             xpOrbs.push({ x: x, y: y, size: 5, value: value, color: '#39ff14' }); // Neon green XP orb
        }
        // --- New Dash Function ---
        function triggerDash() {
            if (!player || player.isDashing || gamePaused) return;
            const now = Date.now();
            if (now - player.lastDashTime < player.dashCooldown) return; // Check cooldown

            player.lastDashTime = now;
            player.isDashing = true;
            player.dashTimer = player.dashDuration / 1000; // Convert ms to s

            let dashDirX = player.vx;
            let dashDirY = player.vy;
            let mag = Math.hypot(dashDirX, dashDirY);

            if (mag < 10) { // If not moving much, dash in aiming direction
                dashDirX = Math.cos(player.weaponAngle);
                dashDirY = Math.sin(player.weaponAngle);
            } else { // Dash in current movement direction
                dashDirX /= mag;
                dashDirY /= mag;
            }

            player.dashTargetVX = dashDirX * player.dashSpeed;
            player.dashTargetVY = dashDirY * player.dashSpeed;

            if (touchDashCooldown) { // Reset cooldown UI
                touchDashCooldown.style.transition = 'none'; // No transition for reset
                touchDashCooldown.style.transform = 'translateY(0%)';
            }
        }

        // --- Bomb Function ---
        function triggerBomb() {
            if (!player || gamePaused) return;
            if (player.bombs <= 0) return; // No bombs left
            const now = Date.now();
            if (now - player.lastBombTime < player.bombCooldown) return; // Check cooldown

            player.bombs--;
            player.lastBombTime = now;

            // Massive explosion particles
            spawnParticleEmitter(player.x, player.y, '#ffaa00', 100);
            spawnParticleEmitter(player.x, player.y, '#ff4400', 80);

            // Damage all enemies in radius
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < player.bombRadius) {
                    handleEnemyHit(e, player.bombDamage);
                }
            }

            // Destroy all enemy projectiles in radius
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                const dx = p.x - player.x;
                const dy = p.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < player.bombRadius) {
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        // --- Orbital Weapon System ---
        function addOrbitalWeapon() {
            const orbitalCount = player.orbitalCount || 0;
            const angleOffset = (Math.PI * 2 / Math.max(1, orbitalCount)) * (orbitalCount - 1);
            orbitalWeapons.push({
                angle: angleOffset,
                distance: 60,
                size: 15,
                damage: 40,
                color: '#silver',
                speed: 2 // Rotation speed
            });
        }

        function updateOrbitalWeapons(delta) {
            orbitalWeapons.forEach(weapon => {
                weapon.angle += weapon.speed * delta;
                weapon.x = player.x + Math.cos(weapon.angle) * weapon.distance;
                weapon.y = player.y + Math.sin(weapon.angle) * weapon.distance;

                // Check collision with enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];

                    let hitDetected = false;

                    // Check limb hits first for multipart bosses
                    if (e.isMultipart && e.limbs) {
                        for (let li = 0; li < e.limbs.length; li++) {
                            const limb = e.limbs[li];
                            if (limb.health <= 0) continue;

                            const limbX = e.x + limb.offsetX;
                            const limbY = e.y + limb.offsetY;

                            // Circle-rectangle collision for orbital weapons
                            const closestX = Math.max(limbX - limb.width / 2, Math.min(weapon.x, limbX + limb.width / 2));
                            const closestY = Math.max(limbY - limb.height / 2, Math.min(weapon.y, limbY + limb.height / 2));
                            const dx = weapon.x - closestX;
                            const dy = weapon.y - closestY;

                            if (dx*dx + dy*dy < weapon.size * weapon.size) {
                                limb.health -= weapon.damage;
                                spawnParticleEmitter(weapon.x, weapon.y, limb.color, 5);

                                if (limb.health <= 0) {
                                    limb.health = 0;
                                    createXpOrb(limbX, limbY, limb.xp);
                                    spawnParticleEmitter(limbX, limbY, limb.color, 15);
                                }

                                hitDetected = true;
                                break;
                            }
                        }
                    }

                    // If no limb hit, check body hit
                    if (!hitDetected) {
                        const dx = e.x - weapon.x;
                        const dy = e.y - weapon.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < (e.size + weapon.size)) {
                            handleEnemyHit(e, weapon.damage);
                            spawnParticleEmitter(weapon.x, weapon.y, '#ffaa00', 5);
                        }
                    }
                }
            });
        }

        // --- Stun Projectile System ---
        function shootStunProjectile(angle) {
            stunProjectiles.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * 300,
                vy: Math.sin(angle) * 300,
                size: 5,
                damage: 5,
                stunDuration: 2, // 2 seconds
                lifetime: 10,
                color: '#00ffff'
            });
        }

        function updateStunProjectiles(delta) {
            for (let i = stunProjectiles.length - 1; i >= 0; i--) {
                const p = stunProjectiles[i];
                p.x += p.vx * delta;
                p.y += p.vy * delta;
                p.lifetime -= delta;

                if (p.lifetime <= 0 || p.x < 0 || p.x > world.width || p.y < 0 || p.y > world.height) {
                    stunProjectiles.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                enemies.forEach(e => {
                    const dx = e.x - p.x;
                    const dy = e.y - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < (e.size + p.size)) {
                        e.stunned = true;
                        e.stunnedUntil = Date.now() + p.stunDuration * 1000;
                        handleEnemyHit(e, p.damage);
                        spawnParticleEmitter(p.x, p.y, '#00ffff', 3);
                    }
                });
            }
        }

        // --- Charge Shot System ---
        function startChargingShot() {
            if (!player.hasChargeShot) return;
            isCharging = true;
            chargeStartTime = Date.now();
        }

        function releaseChargeShot() {
            if (!isCharging || !player.hasChargeShot) return;
            const chargeTime = (Date.now() - chargeStartTime) / 1000;
            isCharging = false;

            if (chargeTime < 0.5) return; // Minimum charge time

            const chargePower = Math.min(3, chargeTime / 1.5); // Max 3x power at 1.5s
            const angle = player.weaponAngle;

            // Huge explosion at muzzle
            spawnParticleEmitter(player.x, player.y, '#ff00ff', 30);

            projectiles.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * 200,
                vy: Math.sin(angle) * 200,
                size: 20 * chargePower,
                damage: player.projectileDamage * chargePower * 5,
                lifetime: 5,
                pierceCount: 999,
                hitEnemies: [],
                isCharged: true,
                chargePower: chargePower
            });
        }

        // --- Rage Mode System ---
        function checkRageMode() {
            if (!player.hasRageMode) return;
            const now = Date.now();

            // Activate rage when HP < 30%
            if (player.health < player.maxHealth * 0.3 && !player.rageActive) {
                player.rageActive = true;
                player.rageEndTime = now + 10000; // 10 seconds
                player.rageSpeed = player.speed;
                player.rageDamage = player.projectileDamage;
                player.rageFireRate = player.fireRate;
                // Apply boosts
                player.speed *= 2;
                player.projectileDamage *= 2;
                player.fireRate *= 2;
                spawnParticleEmitter(player.x, player.y, '#ff0000', 50);
            }

            // Deactivate rage when time runs out
            if (player.rageActive && now > player.rageEndTime) {
                player.rageActive = false;
                player.speed = player.rageSpeed;
                player.projectileDamage = player.rageDamage;
                player.fireRate = player.rageFireRate;
            }

            // Particle effect while raging
            if (player.rageActive && Math.random() > 0.7) {
                particles.push(createParticle(player.x, player.y, '#ff0000', 4, 0.3, 0, 0));
            }
        }

        // --- Kill Streak System ---
        function checkKillStreak() {
            if (killStreak >= 38) {
                // Spawn reinforcement enemies
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 / 4) * i;
                    const dist = 200;
                    enemies.push({
                        id: Math.random(),
                        x: player.x + Math.cos(angle) * dist,
                        y: player.y + Math.sin(angle) * dist,
                        id_key: "Tank",
                        name: "Reinforcement",
                        size: 70,
                        speed: 60, // Boosted speed
                        health: 400,
                        xp: 100,
                        shape: 'rect',
                        color: '#ff00ff',
                        damage: 30,
                        maxHealth: 400,
                        isBoosted: true
                    });
                }
                killStreak = 0; // Reset streak
            }
        }

        // --- Drawing ---
        function draw() {
            if (!ctx) return;
            // Use biome background color
            const biomeInfo = biomes[currentBiome];
            ctx.fillStyle = biomeInfo.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!player) return;

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            drawWorld();
            xpOrbs.forEach(orb => drawDrop(orb));
            projectiles.forEach(p => drawProjectile(p));
            enemyProjectiles.forEach(p => drawEnemyProjectile(p)); // <-- NEW: Draw enemy projectiles
            stunProjectiles.forEach(p => drawStunProjectile(p)); // <-- NEW: Draw stun projectiles
            orbitalWeapons.forEach(w => drawOrbitalWeapon(w)); // <-- NEW: Draw orbital weapons
            enemies.forEach(e => drawEnemy(e)); // <-- Updated function
            particles.forEach(p => drawParticle(p)); // <-- NEW: Draw particles
            drawPlayerCharacter();

            // Draw charge indicator
            if (isCharging) {
                const chargeTime = (Date.now() - chargeStartTime) / 1000;
                const progress = Math.min(1, chargeTime / 1.5);
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(player.x, player.y, 30 + progress * 20, 0, Math.PI * 2 * progress);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }

            ctx.restore();
        }
        function drawWorld() {
            // Use biome grid color
            const biomeInfo = biomes[currentBiome];
            ctx.strokeStyle = biomeInfo.gridColor;
            ctx.lineWidth = 1;
            const gridSize = 100;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            for (let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, camera.y);
                ctx.lineTo(x, camera.y + canvas.height);
                ctx.stroke();
            }
             for (let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(camera.x, y);
                ctx.lineTo(camera.x + canvas.width, y);
                ctx.stroke();
            }

            // Draw biome-specific effects
            if (currentBiome === 'ice') {
                // Draw ice patches/shimmer
                ctx.fillStyle = biomeInfo.iceColor;
                ctx.globalAlpha = 0.1;
                for (let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) {
                    for (let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) {
                        if (Math.random() > 0.7) {
                            ctx.fillRect(x, y, gridSize * 0.8, gridSize * 0.8);
                        }
                    }
                }
                ctx.globalAlpha = 1.0;
            }

            // Draw lava pits
            drawLavaPits();
        }

        function drawLavaPits() {
            if (currentBiome !== 'heat') return;

            const biomeInfo = biomes.heat;
            for (let pit of lavaPits) {
                // Draw glowing lava pit
                ctx.fillStyle = biomeInfo.lavaColor;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(pit.x, pit.y, pit.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Outer glow
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(pit.x, pit.y, pit.size / 2 + 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0;
            }
        }
        function drawPlayerCharacter() {
             // Draw dash "after-image" if dashing
             if (player.isDashing) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; // Faint dash color
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.weaponAngle + Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(0, -player.size * 0.8);
                ctx.lineTo(player.size * 0.6, player.size * 0.7);
                ctx.lineTo(-player.size * 0.6, player.size * 0.7);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
             }

             ctx.fillStyle = '#00ffff'; // Player color
             ctx.font = `${player.size * 2}px Arial`;
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             
             ctx.save();
             ctx.translate(player.x, player.y);
             ctx.rotate(player.weaponAngle + Math.PI / 2); // Point ship towards aim
             ctx.beginPath();
             ctx.moveTo(0, -player.size * 0.8);
             ctx.lineTo(player.size * 0.6, player.size * 0.7);
             ctx.lineTo(-player.size * 0.6, player.size * 0.7);
             ctx.closePath();
             ctx.fill();
             ctx.restore();

             const barWidth = player.size * 2;
             const barHeight = 6;
             const barX = player.x - barWidth / 2;
             const barY = player.y - player.size - 15;
             ctx.fillStyle = '#555';
             ctx.fillRect(barX, barY, barWidth, barHeight);
             ctx.fillStyle = 'lime';
             ctx.fillRect(barX, barY, barWidth * (player.health / player.maxHealth), barHeight);
        }

        // --- NEW: Updated drawEnemy function ---
        function drawEnemy(e) {
             // Draw limbs first (behind body) for multipart bosses
             if (e.isMultipart && e.limbs) {
                 e.limbs.forEach(limb => {
                     if (limb.health > 0) {
                         const limbX = e.x + limb.offsetX;
                         const limbY = e.y + limb.offsetY;

                         // Draw limb
                         ctx.fillStyle = limb.color;
                         ctx.fillRect(limbX - limb.width / 2, limbY - limb.height / 2, limb.width, limb.height);

                         // Draw limb health bar
                         if (limb.health < limb.maxHealth) {
                             const barWidth = limb.width;
                             const barHeight = 3;
                             const barX = limbX - barWidth / 2;
                             const barY = limbY - limb.height / 2 - 6;
                             ctx.fillStyle = '#660000';
                             ctx.fillRect(barX, barY, barWidth, barHeight);
                             ctx.fillStyle = '#ff6600';
                             ctx.fillRect(barX, barY, barWidth * (limb.health / limb.maxHealth), barHeight);
                         }
                     }
                 });
             }

             // Add blue outline if stunned
             if (e.stunned && e.stunnedUntil > Date.now()) {
                 ctx.strokeStyle = '#00ffff';
                 ctx.lineWidth = 3;
                 ctx.beginPath();
                 drawEnemyShape(e, true); // Draw outline only
                 ctx.stroke();
             }

             // Draw enemy shape
             ctx.fillStyle = e.color;
             ctx.beginPath();
             drawEnemyShape(e, false);
             ctx.fill();

             // Draw health bar
             if (e.health < e.maxHealth) {
                 const barWidth = e.size * 1.5;
                 const barHeight = 4;
                 const barX = e.x - barWidth / 2;
                 const barY = e.y - e.size - 10;
                 ctx.fillStyle = 'red';
                 ctx.fillRect(barX, barY, barWidth, barHeight);
                 ctx.fillStyle = 'green';
                 ctx.fillRect(barX, barY, barWidth * (e.health / e.maxHealth), barHeight);
             }
        }

        function drawEnemyShape(e, outlineOnly) {
             const s = e.size;
             const x = e.x;
             const y = e.y;

             if (e.shape === 'rectangle' || e.shape === 'rect') {
                 // Rectangle (Process box)
                 if (outlineOnly) {
                     ctx.rect(x - s/2, y - s/2, s, s);
                 } else {
                     ctx.rect(x - s/2, y - s/2, s, s);
                 }
             } else if (e.shape === 'diamond') {
                 // Diamond (Decision)
                 ctx.moveTo(x, y - s/2);
                 ctx.lineTo(x + s/2, y);
                 ctx.lineTo(x, y + s/2);
                 ctx.lineTo(x - s/2, y);
                 ctx.closePath();
             } else if (e.shape === 'oval') {
                 // Oval (Terminal)
                 ctx.ellipse(x, y, s/2, s/3, 0, 0, Math.PI * 2);
             } else if (e.shape === 'parallelogram') {
                 // Parallelogram (Input/Output)
                 const offset = s * 0.3;
                 ctx.moveTo(x - s/2 + offset, y - s/2);
                 ctx.lineTo(x + s/2 + offset, y - s/2);
                 ctx.lineTo(x + s/2 - offset, y + s/2);
                 ctx.lineTo(x - s/2 - offset, y + s/2);
                 ctx.closePath();
             } else if (e.shape === 'trapezoid') {
                 // Trapezoid (Manual Operation)
                 const topWidth = s * 0.8;
                 ctx.moveTo(x - topWidth/2, y - s/2);
                 ctx.lineTo(x + topWidth/2, y - s/2);
                 ctx.lineTo(x + s/2, y + s/2);
                 ctx.lineTo(x - s/2, y + s/2);
                 ctx.closePath();
             } else if (e.shape === 'hexagon') {
                 // Hexagon (for boss)
                 const radius = s / 2;
                 for (let i = 0; i < 6; i++) {
                     const angle = (Math.PI / 3) * i;
                     const px = x + radius * Math.cos(angle);
                     const py = y + radius * Math.sin(angle);
                     if (i === 0) ctx.moveTo(px, py);
                     else ctx.lineTo(px, py);
                 }
                 ctx.closePath();
             } else if (e.shape === 'circle') {
                 // Circle (fallback)
                 ctx.arc(x, y, s/2, 0, Math.PI * 2);
             } else {
                 // Default to square
                 if (outlineOnly) {
                     ctx.rect(x - s/2, y - s/2, s, s);
                 } else {
                     ctx.rect(x - s/2, y - s/2, s, s);
                 }
             }
        }

        function drawProjectile(p) {
            if (p.isCharged) {
                // Draw charged shot - big purple ball with glow
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            } else if (p.isCrit) {
                ctx.fillStyle = '#ff0000'; // Red for crits
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2 * 1.5, 0, Math.PI * 2); // Larger
                ctx.fill();
            } else {
                ctx.fillStyle = '#00ffff'; // Cyan laser
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawEnemyProjectile(p) {
            ctx.fillStyle = p.color; // Red ball
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawStunProjectile(p) {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = p.color;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawOrbitalWeapon(w) {
            // Draw spinning axe
            ctx.save();
            ctx.translate(w.x, w.y);
            ctx.rotate(w.angle * 3); // Spin the axe visually
            ctx.fillStyle = '#c0c0c0'; // Silver
            ctx.strokeStyle = '#808080'; // Gray outline
            ctx.lineWidth = 2;

            // Draw axe shape (simple cross)
            ctx.beginPath();
            ctx.moveTo(-w.size, 0);
            ctx.lineTo(w.size, 0);
            ctx.moveTo(0, -w.size);
            ctx.lineTo(0, w.size);
            ctx.stroke();

            // Draw axe blades
            ctx.fillRect(-w.size, -w.size/3, w.size*2, w.size/1.5);

            ctx.restore();
        }
        
        function drawDrop(drop) {
             ctx.fillStyle = drop.color;
             ctx.beginPath(); ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2); ctx.fill();
        }

        // --- NEW: Draw Particle ---
        function drawParticle(p) {
            ctx.globalAlpha = Math.max(0, p.lifetime / 0.5); // Fade out
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0; // Reset alpha
        }

        // --- Camera ---
        function updateCamera() {
            if (!player || !canvas) return;
            const targetX = player.x - canvas.width / 2;
            const targetY = player.y - canvas.height / 2;
            const lerpFactor = 0.08; 
            camera.x += (targetX - camera.x) * lerpFactor;
            camera.y += (targetY - camera.y) * lerpFactor;
            camera.x = Math.max(0, Math.min(world.width - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(world.height - canvas.height, camera.y));
        }

        // --- UI & Event Listeners ---
        function updateHUD() {
            if(ammoText) ammoText.textContent = player?.ammo ?? 'N/A';
            if(bombText) bombText.textContent = player?.bombs ?? 0;
            if(scoreText) scoreText.textContent = score;
            if(levelText) levelText.textContent = player?.level ?? 1;
            if(biomeText) biomeText.textContent = biomes[currentBiome].name;
            if(timeText) timeText.textContent = Math.floor(gameTime) + 's';
            if(xpBarFill && player) xpBarFill.style.width = `${player ? (player.xp / player.xpToNextLevel) * 100 : 0}%`;
        }
        function updateCooldowns() {
            if (!player || !touchDashCooldown) return;
            const now = Date.now();
            const timeSinceDash = now - player.lastDashTime;
            const cooldownPercent = Math.min(1, timeSinceDash / player.dashCooldown);

            if (cooldownPercent < 1) {
                if (touchDashCooldown.style.transition === 'none') {
                    // Force browser reflow to apply transition after reset
                    touchDashCooldown.offsetHeight; 
                    touchDashCooldown.style.transition = 'transform 0.1s linear';
                }
                touchDashCooldown.style.transform = `translateY(${(1 - cooldownPercent) * 100}%)`;
            } else {
                touchDashCooldown.style.transform = 'translateY(100%)'; // Cooldown finished, hide overlay
            }
        }
        function gainXp(amount) {
            if (!player) return;
            player.xp += amount;
            if (player.xp >= player.xpToNextLevel) {
                player.level++;
                player.xp -= player.xpToNextLevel;
                player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
                showLevelUpModal();
            }
        }
        function showLevelUpModal() {
            gamePaused = true;
            if (!upgradeOptionsContainer) return;
            upgradeOptionsContainer.innerHTML = '';
            const availableUpgrades = Object.keys(powerUpTypes);
            const chosenUpgrades = [];
            while(chosenUpgrades.length < 3 && availableUpgrades.length > 0) {
                const randIndex = Math.floor(Math.random() * availableUpgrades.length);
                chosenUpgrades.push(availableUpgrades.splice(randIndex, 1)[0]);
            }
            chosenUpgrades.forEach(key => {
                const upgrade = powerUpTypes[key];
                const button = document.createElement('button');
                button.className = "modal-button bg-gray-700 p-3 rounded-lg text-left w-full hover:bg-cyan-500 border border-cyan-500";
                button.innerHTML = `<div class="font-bold text-lg text-cyan-300">${upgrade.name}</div><div class="text-sm text-gray-300 font-sans">${upgrade.description}</div>`;
                button.onclick = () => { applyUpgrade(key); };
                upgradeOptionsContainer.appendChild(button);
            });
           if(levelUpModal) levelUpModal.classList.remove('hidden');
        }
        function applyUpgrade(key) {
             if (!player) return;
            powerUpTypes[key].apply(player);
            if(levelUpModal) levelUpModal.classList.add('hidden');
            gamePaused = false;
        }
        
        function askQuestion() {
            if (gameOver || gamePaused) return;
            gamePaused = true;
            const questionData = questionGenerator.generate();
            if(questionText) questionText.textContent = questionData.q;
            if(answerButtons) answerButtons.innerHTML = '';
            questionData.a.forEach((answer, index) => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.className = "modal-button bg-gray-700 p-3 rounded-lg hover:bg-cyan-500 border border-cyan-500";
                button.onclick = () => checkAnswer(index === questionData.c);
                if(answerButtons) answerButtons.appendChild(button);
            });
            if(questionModal) questionModal.classList.remove('hidden');
        }
        function checkAnswer(isCorrect) {
             if (!player) return;
            if (isCorrect) {
                correctAnswers++;
                player.ammo += 25;
            } else {
                incorrectAnswers++;
            }
           if(questionModal) questionModal.classList.add('hidden');
            gamePaused = false;
        }
        
        // --- Input Listeners ---
        window.addEventListener('keydown', (e) => {
            if (e.code) { // Check if e.code exists
                keys[e.code] = true;
                if(e.code.toLowerCase() === 'keyq') {
                    askQuestion();
                }
                if(e.code.toLowerCase() === 'shiftleft') { // Dash key
                    triggerDash();
                }
                if(e.code.toLowerCase() === 'keyb') { // Bomb key
                    triggerBomb();
                }
            }
        });
        window.addEventListener('keyup', (e) => { 
            if (e.code) { // Check if e.code exists
                keys[e.code] = false; 
            }
        });
        window.addEventListener('mousedown', (e) => { if(e.button === 0) keys['mouseLeft'] = true; });
        window.addEventListener('mouseup', (e) => { if(e.button === 0) keys['mouseLeft'] = false; });
        window.addEventListener('resize', resizeCanvas);
        
        // --- Touch Listeners ---
        function handleTouchStart(e) {
            const target = e.target;

            // Allow default behavior for modal buttons and text inputs
            if (target.closest('.modal-button') || target.closest('.nickname-input')) {
                // This is a button or input. Let the browser handle it.
                return;
            }
            
            // For all other touches (joystick, shoot, question btn), prevent default browser behavior
            e.preventDefault();

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier;
                if (activeTouches[touchId]) continue; // Already tracking this touch

                const x = touch.clientX; const y = touch.clientY;

                // Check for new bomb button
                if (touchBombButton) {
                    const bombRect = touchBombButton.getBoundingClientRect();
                    if (x > bombRect.left && x < bombRect.right && y > bombRect.top && y < bombRect.bottom) {
                        activeTouches[touchId] = { type: 'bomb' };
                        // We'll trigger the bomb on touch *end*
                        continue; // This touch is handled
                    }
                }

                // Check for new dash button
                if (touchDashButton) {
                    const dashRect = touchDashButton.getBoundingClientRect();
                    if (x > dashRect.left && x < dashRect.right && y > dashRect.top && y < dashRect.bottom) {
                        activeTouches[touchId] = { type: 'dash' };
                        // We'll trigger the dash on touch *end*
                        continue; // This touch is handled
                    }
                }

                // Check for new touch question button
                if (touchQuestionButton) {
                    const questionRect = touchQuestionButton.getBoundingClientRect();
                    if (x > questionRect.left && x < questionRect.right && y > questionRect.top && y < questionRect.bottom) {
                        activeTouches[touchId] = { type: 'question' };
                        // We'll trigger the question on touch *end* to prevent accidental multi-taps
                        continue; // This touch is handled
                    }
                }

                if (joystickArea) {
                    const joystickRect = joystickArea.getBoundingClientRect();
                    if (x > joystickRect.left && x < joystickRect.right && y > joystickRect.top && y < joystickRect.bottom) {
                        if (joystickTouchId === null) {
                            joystickTouchId = touchId;
                            // IMPROVEMENT: Set joystick center to the *actual touch position* for a "floating" joystick
                            joystickStart.x = x; 
                            joystickStart.y = y;
                            activeTouches[touchId] = { type: 'move', startX: x, startY: y, currentX: x, currentY: y };
                        }
                    }
                }
                 if (shootArea) {
                     const shootRect = shootArea.getBoundingClientRect();
                     if (x > shootRect.left && x < shootRect.right && y > shootRect.top && y < shootRect.bottom) {
                        keys['touchShoot'] = true;
                        activeTouches[touchId] = { type: 'shoot' };
                    }
                 }
            }
        }
        function handleTouchMove(e) {
             // Only prevent default if we are tracking at least one of the changed touches
             let shouldPreventDefault = false;

             for (const touch of e.changedTouches) {
                 const touchId = touch.identifier; // Get the touch ID
                 if (activeTouches[touchId]) { // Is this a touch we are managing?
                    shouldPreventDefault = true;

                     // Check using the correct touchId variable
                    if (touchId === joystickTouchId && joystickArea && activeTouches[touchId].type === 'move') {
                         activeTouches[touchId].currentX = touch.clientX;
                         activeTouches[touchId].currentY = touch.clientY;
                         
                         const deltaX = touch.clientX - joystickStart.x;
                         const deltaY = touch.clientY - joystickStart.y;
                         const angle = Math.atan2(deltaY, deltaX);
                         const distance = Math.min(joystickArea.clientWidth / 3, Math.hypot(deltaX, deltaY));
                         const moveX = distance * Math.cos(angle);
                         const moveY = distance * Math.sin(angle);
                         if(joystickNub) joystickNub.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;
                         
                         moveInput.x = moveX / (joystickArea.clientWidth / 3);
                         moveInput.y = moveY / (joystickArea.clientWidth / 3);
                     }
                 }
             }

             if (shouldPreventDefault) {
                e.preventDefault();
             }
        }
        function handleTouchEnd(e) {
            let shouldPreventDefault = false;

            for (const touch of e.changedTouches) {
                const touchId = touch.identifier; // Define touchId for this scope
                if (activeTouches[touchId]) { // Was this a touch we were managing?
                    shouldPreventDefault = true;

                    if (touchId === joystickTouchId) {
                        joystickTouchId = null;
                        if(joystickNub) joystickNub.style.transform = 'translate(-50%, -50%)';
                        moveInput = { x: 0, y: 0 };
                    }
                    if (activeTouches[touchId]?.type === 'shoot') {
                        keys['touchShoot'] = false;
                    }
                    // Check if this was the question button touch
                    if (activeTouches[touchId]?.type === 'question') {
                        askQuestion(); // Trigger question on tap release
                    }
                    // Check if this was the dash button touch
                    if (activeTouches[touchId]?.type === 'dash') {
                        triggerDash(); // Trigger dash on tap release
                    }
                    // Check if this was the bomb button touch
                    if (activeTouches[touchId]?.type === 'bomb') {
                        triggerBomb(); // Trigger bomb on tap release
                    }
                    delete activeTouches[touchId];
                }
            }

            if (shouldPreventDefault) {
                e.preventDefault();
            }
        }

        // --- Other Utility Functions ---
        function detectTouchDevice() {
            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if(touchControlsContainer) { 
                if (isTouchDevice) {
                    touchControlsContainer.classList.remove('hidden');
                    if(hudQuestionButton) hudQuestionButton.style.display = 'none'; // Hide desktop button
                } else {
                    touchControlsContainer.classList.add('hidden'); // Hide touch controls
                    if(hudQuestionButton) hudQuestionButton.style.display = 'inline-block'; // Show desktop button
                }
            }
        }
        function resizeCanvas() {
            if(canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }

        // --- Initialization ---
        initUI(); // Initialize references to DOM elements FIRST
        resizeCanvas();
        detectTouchDevice(); // Detect touch before adding listeners

        // Start button listener removed
        if (restartButton) restartButton.addEventListener('click', () => {
             // startModal logic removed
             if(gameOverModal) gameOverModal.classList.add('hidden');
             startGame(); // Restart the game directly
        });
        if (hudQuestionButton) hudQuestionButton.addEventListener('click', askQuestion);

        // Add main touch listeners to the game container
        gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameContainer.addEventListener('touchend', handleTouchEnd, { passive: false });
        gameContainer.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Start the game automatically on load
        startGame();
    </script>
</body>
</html>
